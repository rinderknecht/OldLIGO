(* Token specification for PyLIGO *)

(* Vendor dependencies *)

module Region    = Simple_utils.Region
module Markup    = LexerLib.Markup
module Directive = Preprocessor.Directive

(* Utility modules and types *)

module SMap = Map.Make (String)
module Wrap = Lexing_shared.Wrap
module Attr = Lexing_shared.Attr

let sprintf = Printf.sprintf

let wrap = Wrap.wrap

module T =
  struct
    (* A lexeme is the concrete syntax of a token *)

    type lexeme = string

    (* Definition of tokens generated by "menhir --only-tokens"

       It contains [token] and ['a terminal] types. The first one we
       redefine manually here (by type [t]) but the second one we need
       to satisfy Menhir's Inspection API.  *)

    include Mh_py_tokens.MenhirToken

    (* TOKENS *)

    type t =
      (* Preprocessing directives *)

      Directive of Directive.t

      (* Literals *)

    | String   of lexeme Wrap.t
    | Verbatim of lexeme Wrap.t
    | Bytes    of (lexeme * Hex.t) Wrap.t
    | Int      of (lexeme * Z.t) Wrap.t
    | Nat      of (lexeme * Z.t) Wrap.t
    | Mutez    of (lexeme * Int64.t) Wrap.t
    | Tez      of (lexeme * Int64.t) Wrap.t
    | Ident    of lexeme Wrap.t              (* foo  *)
    | UIdent   of lexeme Wrap.t              (* Foo  *)
    | EIdent   of lexeme Wrap.t              (* @foo *)
    | Lang     of lexeme Region.reg Region.reg
    | Attr     of Attr.t Region.reg

    (* Symbols *)

    | ARROW      of lexeme Wrap.t  (* ->  *)
    | XOR        of lexeme Wrap.t  (* ^   *)
    | MINUS      of lexeme Wrap.t  (* -   *)
    | PLUS       of lexeme Wrap.t  (* +   *)
    | TIMES      of lexeme Wrap.t  (* *   *)
    | EXP        of lexeme Wrap.t  (* **  *)
    | SLASH2     of lexeme Wrap.t  (* //  *)
    | PERCENT    of lexeme Wrap.t  (* %   *)
    | LPAR       of lexeme Wrap.t  (* (   *)
    | RPAR       of lexeme Wrap.t  (* )   *)
    | LBRACKET   of lexeme Wrap.t  (* [   *)
    | RBRACKET   of lexeme Wrap.t  (* ]   *)
    | LBRACE     of lexeme Wrap.t  (* {   *)
    | RBRACE     of lexeme Wrap.t  (* }   *)
    | COMMA      of lexeme Wrap.t  (* ,   *)
    | SEMI       of lexeme Wrap.t  (* ;   *)
    | VBAR       of lexeme Wrap.t  (* |   *)
    | AMPERSAND  of lexeme Wrap.t  (* &   *)
    | COLON      of lexeme Wrap.t  (* :   *)
    | DOT        of lexeme Wrap.t  (* .   *)
    | TILDE      of lexeme Wrap.t  (* ~   *)
    | LSHIFT     of lexeme Wrap.t  (* <<  *)
    | RSHIFT     of lexeme Wrap.t  (* >>  *)
    | EQ         of lexeme Wrap.t  (* =   *)
    | EQ2        of lexeme Wrap.t  (* ==  *)
    | NE         of lexeme Wrap.t  (* !=  *)
    | LT         of lexeme Wrap.t  (* <   *)
    | GT         of lexeme Wrap.t  (* >   *)
    | LE         of lexeme Wrap.t  (* <=  *)
    | GE         of lexeme Wrap.t  (* >=  *)
    | PLUS_EQ    of lexeme Wrap.t  (* +=  *)
    | MINUS_EQ   of lexeme Wrap.t  (* -=  *)
    | TIMES_EQ   of lexeme Wrap.t  (* *=  *)
    | SLASH2_EQ  of lexeme Wrap.t  (* //= *)
    | PERCENT_EQ of lexeme Wrap.t  (* %=  *)
    | AND_EQ     of lexeme Wrap.t  (* &=  *)
    | OR_EQ      of lexeme Wrap.t  (* |=  *)
    | XOR_EQ     of lexeme Wrap.t  (* ^=  *)
    | RSHIFT_EQ  of lexeme Wrap.t  (* >>= *)
    | LSHIFT_EQ  of lexeme Wrap.t  (* <<= *)
    | EXP_EQ     of lexeme Wrap.t  (* **= *)
    | WILD       of lexeme Wrap.t  (* _   *)
    | GRAVE      of lexeme Wrap.t  (* `   *)
    | BACKSLASH  of lexeme Wrap.t  (* \   *)


    (* Keywords (except True, False and None) *)

    | And      of lexeme Wrap.t (* and      *)
(*  | As       of lexeme Wrap.t (* as       *) *)
    | Assert   of lexeme Wrap.t (* assert   *)
(*  | Async    of lexeme Wrap.t (* async    *)
    | Await    of lexeme Wrap.t (* await    *)
    | Break    of lexeme Wrap.t (* break    *) *)
    | Case     of lexeme Wrap.t (* case     *)
    | Class    of lexeme Wrap.t (* class    *)
(*  | Continue of lexeme Wrap.t (* continue *) *)
    | Const    of lexeme Wrap.t (* const    *) (* Absent in Python 3 *)
    | Def      of lexeme Wrap.t (* def      *)
(*  | Del      of lexeme Wrap.t (* del      *) *)
    | Elif     of lexeme Wrap.t (* elif     *)
    | Else     of lexeme Wrap.t (* else     *)
(*  | Except   of lexeme Wrap.t (* except   *)
    | Finally  of lexeme Wrap.t (* finally  *) *)
    | For      of lexeme Wrap.t (* for      *)
(*  | From     of lexeme Wrap.t (* from     *)
    | Global   of lexeme Wrap.t (* global   *) *)
    | If       of lexeme Wrap.t (* if       *)
    | In       of lexeme Wrap.t (* in       *)
(*  | Is       of lexeme Wrap.t (* is       *)
    | Import   of lexeme Wrap.t (* import   *) *)
    | Lambda   of lexeme Wrap.t (* lambda   *)
    | Match    of lexeme Wrap.t (* match    *)
    | Module   of lexeme Wrap.t (* module   *) (* Absent in Python 3 *)
(*  | Nonlocal of lexeme Wrap.t (* nonlocal *) *)
    | Not      of lexeme Wrap.t (* not      *)
    | Or       of lexeme Wrap.t (* or       *)
    | Pass     of lexeme Wrap.t (* pass     *)
(*  | Raise    of lexeme Wrap.t (* raise    *) *)
    | Return   of lexeme Wrap.t (* return   *)
(*  | Try      of lexeme Wrap.t (* try      *) *)
    | Type     of lexeme Wrap.t (* type     *) (* Absent in Python 3 *)
    | Var      of lexeme Wrap.t (* var      *) (* Absent in Python 3 *)
    | While    of lexeme Wrap.t (* while    *)
(*  | With     of lexeme Wrap.t (* with     *)
    | Yield    of lexeme Wrap.t (* yield    *) *)

    (* Virtual tokens *)

    | BEGIN     of lexeme Wrap.t (* Start of block                   *)
    | END       of lexeme Wrap.t (* End of block                     *)
    | INDENT    of    int Wrap.t (* Indentation before a token       *)
    | TOP_LEVEL of   unit Wrap.t (* Followed by a token at top-level *)
    | ZWSP      of   unit Wrap.t (* Zero-Width SPace                 *)

    (* End-Of-File *)

    | EOF of lexeme Wrap.t

    type token = t


    (* FROM TOKENS TO LEXEMES *)

    let to_lexeme = function
      (* Directives *)

      Directive d -> [(Directive.to_lexeme d).Region.value]

      (* Literals *)

    | String   t -> [sprintf "%S" t#payload] (* Escaped *)
    | Verbatim t -> [String.escaped t#payload]
    | Bytes    t -> [fst t#payload]
    | Int      t
    | Nat      t -> [fst t#payload]
    | Mutez    t -> [fst t#payload]
    | Tez      t -> [fst t#payload]
    | Ident    t
    | UIdent   t
    | EIdent   t -> [t#payload]
    | Attr     t -> [Attr.to_lexeme t.Region.value]
    | Lang  lang -> ["[%" ^ Region.(lang.value.value)]

    (* Symbols *)

    | ARROW      t
    | XOR        t
    | MINUS      t
    | PLUS       t
    | TIMES      t
    | EXP        t
    | SLASH2     t
    | PERCENT    t
    | LPAR       t
    | RPAR       t
    | LBRACKET   t
    | RBRACKET   t
    | LBRACE     t
    | RBRACE     t
    | COMMA      t
    | SEMI       t
    | VBAR       t
    | AMPERSAND  t
    | COLON      t
    | DOT        t
    | TILDE      t
    | LSHIFT     t
    | RSHIFT     t
    | EQ         t
    | EQ2        t
    | NE         t
    | LT         t
    | GT         t
    | LE         t
    | GE         t
    | PLUS_EQ    t
    | MINUS_EQ   t
    | TIMES_EQ   t
    | SLASH2_EQ  t
    | PERCENT_EQ t
    | AND_EQ     t
    | OR_EQ      t
    | XOR_EQ     t
    | RSHIFT_EQ  t
    | LSHIFT_EQ  t
    | EXP_EQ     t
    | WILD       t
    | GRAVE      t
    | BACKSLASH  t

    (* Keywords *)

    | And      t
(*  | As       t *)
    | Assert   t
(*  | Async    t
    | Await    t
    | Break    t *)
    | Case     t
    | Class    t
(*  | Continue t *)
    | Const    t
    | Def      t
(*  | Del      t *)
    | Elif     t
    | Else     t
(*  | Except   t
    | Finally  t *)
    | For      t
(*  | From     t
    | Global   t *)
    | If       t
    | In       t
(*  | Is       t
    | Import   t *)
    | Lambda   t
    | Match    t
    | Module   t
(*  | Nonlocal t *)
    | Not      t
    | Or       t
    | Pass     t
(*  | Raise    t *)
    | Return   t
(*  | Try      t *)
    | Type     t
    | Var      t
    | While    t
(*  | With     t
    | Yield    t *)
      -> [t#payload]

    (* Virtual tokens *)

    | BEGIN     _
    | END       _ -> [""]
    | INDENT    w -> [String.make w#payload ' ']
    | TOP_LEVEL _ -> [""]
    | ZWSP      _ -> [""]

    (* End-Of-File *)

    | EOF _ -> [""]


    (* KEYWORDS *)

    let wrap_and      = wrap "and"
    let wrap_as       = wrap "as"
    let wrap_assert   = wrap "assert"
(*  let wrap_async    = wrap "async"
    let wrap_await    = wrap "await"
    let wrap_break    = wrap "break" *)
    let wrap_case     = wrap "case"
    let wrap_class    = wrap "class"
(*  let wrap_continue = wrap "continue" *)
    let wrap_const    = wrap "const"
    let wrap_def      = wrap "def"
(*  let wrap_del      = wrap "del" *)
    let wrap_elif     = wrap "elif"
    let wrap_else     = wrap "else"
(*  let wrap_except   = wrap "except"
    let wrap_finally  = wrap "finally" *)
    let wrap_for      = wrap "for"
    let wrap_from     = wrap "from"
(*  let wrap_global   = wrap "global" *)
    let wrap_if       = wrap "if"
    let wrap_in       = wrap "in"
(*  let wrap_is       = wrap "is" *)
    let wrap_import   = wrap "import"
    let wrap_lambda   = wrap "lambda"
    let wrap_match    = wrap "match"
    let wrap_module   = wrap "module"
(*  let wrap_nonlocal = wrap "nonlocal" *)
    let wrap_not      = wrap "not"
    let wrap_or       = wrap "or"
    let wrap_pass     = wrap "pass"
(*  let wrap_raise    = wrap "raise" *)
    let wrap_return   = wrap "return"
(*  let wrap_try      = wrap "try" *)
    let wrap_type     = wrap "type"
    let wrap_var      = wrap "var"
    let wrap_while    = wrap "while"
(*  let wrap_with     = wrap "with"
    let wrap_yield    = wrap "yield" *)

    (* Smart constructors *)

    let mk_And      region = And      (wrap_and      region)
(*  let mk_As       region = As       (wrap_as       region) *)
    let mk_Assert   region = Assert   (wrap_assert   region)
(*  let mk_Async    region = Async    (wrap_async    region)
    let mk_Await    region = Await    (wrap_await    region)
    let mk_Break    region = Break    (wrap_break    region) *)
    let mk_Case     region = Case     (wrap_case     region)
    let mk_Class    region = Class    (wrap_class    region)
(*  let mk_Continue region = Continue (wrap_continue region) *)
    let mk_Const    region = Const    (wrap_const    region)
    let mk_Def      region = Def      (wrap_def      region)
(*  let mk_Del      region = Del      (wrap_del      region) *)
    let mk_Elif     region = Elif     (wrap_elif     region)
    let mk_Else     region = Else     (wrap_else     region)
(*  let mk_Except   region = Except   (wrap_except   region)
    let mk_Finally  region = Finally  (wrap_finally  region) *)
    let mk_For      region = For      (wrap_for      region)
(*  let mk_From     region = From     (wrap_from     region)
    let mk_Global   region = Global   (wrap_global   region) *)
    let mk_If       region = If       (wrap_if       region)
    let mk_In       region = In       (wrap_in       region)
(*  let mk_Is       region = Is       (wrap_is       region)
    let mk_Import   region = Import   (wrap_import   region) *)
    let mk_Lambda   region = Lambda   (wrap_lambda   region)
    let mk_Match    region = Match    (wrap_match    region)
    let mk_Module   region = Module   (wrap_module   region)
(*  let mk_Nonlocal region = Nonlocal (wrap_nonlocal region) *)
    let mk_Not      region = Not      (wrap_not      region)
    let mk_Or       region = Or       (wrap_or       region)
    let mk_Pass     region = Pass     (wrap_pass     region)
(*  let mk_Raise    region = Raise    (wrap_raise    region) *)
    let mk_Return   region = Return   (wrap_return   region)
(*  let mk_Try      region = Try      (wrap_try      region) *)
    let mk_Type     region = Type     (wrap_type     region)
    let mk_Var      region = Var      (wrap_var      region)
    let mk_While    region = While    (wrap_while    region)
(*  let mk_With     region = With     (wrap_with     region)
    let mk_Yield    region = Yield    (wrap_yield    region) *)

    (* All keyword smart constructors *)

    let keywords = [
      mk_And;
(*    mk_As; *)
      mk_Assert;
(*    mk_Async;
      mk_Await;
      mk_Break; *)
      mk_Case;
      mk_Class;
(*    mk_Continue; *)
      mk_Const;
      mk_Def;
(*    mk_Del; *)
      mk_Elif;
      mk_Else;
(*    mk_Except;
      mk_Finally; *)
      mk_For;
(*    mk_From;
      mk_Global; *)
      mk_If;
      mk_In;
(*    mk_Is;
      mk_Import; *)
      mk_Lambda;
      mk_Match;
      mk_Module;
(*    mk_Nonlocal; *)
      mk_Not;
      mk_Or;
      mk_Pass;
(*    mk_Raise; *)
      mk_Return;
(*    mk_Try; *)
      mk_Type;
      mk_Var;
      mk_While;
(*    mk_With;
      mk_Yield *)
    ]

    (* All keywords *)

    let keywords =
      let add map (key, data) =
        match SMap.add ~key ~data map with
          `Ok map -> map
        | `Duplicate -> map in
      let apply map mk_kwd =
        let lexemes = to_lexeme (mk_kwd Region.ghost) in
        List.fold_left ~f:(fun map lex -> add map (lex, mk_kwd))
                       ~init:map lexemes
      in List.fold_left ~f:apply ~init:SMap.empty keywords

    (* Ghost keywords *)

    let ghost_and      = wrap_and      Region.ghost
    let ghost_as       = wrap_as       Region.ghost
    let ghost_assert   = wrap_assert   Region.ghost
(*  let ghost_async    = wrap_async    Region.ghost
    let ghost_await    = wrap_await    Region.ghost
    let ghost_break    = wrap_break    Region.ghost *)
    let ghost_case     = wrap_case     Region.ghost
    let ghost_class    = wrap_class    Region.ghost
(*  let ghost_continue = wrap_continue Region.ghost *)
    let ghost_const    = wrap_const    Region.ghost
    let ghost_def      = wrap_def      Region.ghost
(*  let ghost_del      = wrap_del      Region.ghost *)
    let ghost_elif     = wrap_elif     Region.ghost
    let ghost_else     = wrap_else     Region.ghost
(*  let ghost_except   = wrap_except   Region.ghost
    let ghost_finally  = wrap_finally  Region.ghost *)
    let ghost_for      = wrap_for      Region.ghost
    let ghost_from     = wrap_from     Region.ghost
(*  let ghost_global   = wrap_global   Region.ghost *)
    let ghost_if       = wrap_if       Region.ghost
    let ghost_in       = wrap_in       Region.ghost
(*  let ghost_is       = wrap_is       Region.ghost *)
    let ghost_import   = wrap_import   Region.ghost
    let ghost_lambda   = wrap_lambda   Region.ghost
    let ghost_match    = wrap_match    Region.ghost
    let ghost_module   = wrap_module   Region.ghost
(*  let ghost_nonlocal = wrap_nonlocal Region.ghost *)
    let ghost_not      = wrap_not      Region.ghost
    let ghost_or       = wrap_or       Region.ghost
    let ghost_pass     = wrap_pass     Region.ghost
(*  let ghost_raise    = wrap_raise    Region.ghost *)
    let ghost_return   = wrap_return   Region.ghost
(*  let ghost_try      = wrap_try      Region.ghost *)
    let ghost_type     = wrap_type     Region.ghost
    let ghost_var      = wrap_var      Region.ghost
    let ghost_while    = wrap_while    Region.ghost
(*  let ghost_with     = wrap_with     Region.ghost
    let ghost_yield    = wrap_yield    Region.ghost *)

    let ghost_And      = And      ghost_and
(*  let ghost_As       = As       ghost_as *)
    let ghost_Assert   = Assert   ghost_assert
(*  let ghost_Async    = Async    ghost_async
    let ghost_Await    = Await    ghost_await
    let ghost_Break    = Break    ghost_break *)
    let ghost_Case     = Case     ghost_case
    let ghost_Class    = Class    ghost_class
(*  let ghost_Continue = Continue ghost_continue *)
    let ghost_Const    = Const    ghost_const
    let ghost_Def      = Def      ghost_def
(*  let ghost_Del      = Del      ghost_del *)
    let ghost_Elif     = Elif     ghost_elif
    let ghost_Else     = Else     ghost_else
(*  let ghost_Except   = Except   ghost_except
    let ghost_Finally  = Finally  ghost_finally *)
    let ghost_For      = For      ghost_for
(*  let ghost_From     = From     ghost_from
    let ghost_Global   = Global   ghost_global *)
    let ghost_If       = If       ghost_if
    let ghost_In       = In       ghost_in
(*  let ghost_Is       = Is       ghost_is
    let ghost_Import   = Import   ghost_import *)
    let ghost_Lambda   = Lambda   ghost_lambda
    let ghost_Match    = Match    ghost_match
    let ghost_Module   = Module   ghost_module
(*  let ghost_Nonlocal = Nonlocal ghost_nonlocal *)
    let ghost_Not      = Not      ghost_not
    let ghost_Or       = Or       ghost_or
    let ghost_Pass     = Pass     ghost_pass
(*  let ghost_Raise    = Raise    ghost_raise *)
    let ghost_Return   = Return   ghost_return
(*  let ghost_Try      = Try      ghost_try *)
    let ghost_Type     = Type     ghost_type
    let ghost_Var      = Var      ghost_var
    let ghost_While    = While    ghost_while
(*  let ghost_With     = With     ghost_with
    let ghost_Yield    = Yield    ghost_yield *)


    (* SYMBOLS *)

    let wrap_arrow      = wrap "->"
    let wrap_xor        = wrap "^"
    let wrap_minus      = wrap "-"
    let wrap_plus       = wrap "+"
    let wrap_times      = wrap "*"
    let wrap_exp        = wrap "**"
    let wrap_slash      = wrap "/"
    let wrap_slash2     = wrap "//"
    let wrap_percent    = wrap "%"
    let wrap_at         = wrap "@"
    let wrap_lpar       = wrap "("
    let wrap_rpar       = wrap ")"
    let wrap_lbracket   = wrap "["
    let wrap_rbracket   = wrap "]"
    let wrap_lbrace     = wrap "{"
    let wrap_rbrace     = wrap "}"
    let wrap_comma      = wrap ","
    let wrap_semi       = wrap ";"
    let wrap_vbar       = wrap "|"
    let wrap_ampersand  = wrap "&"
    let wrap_colon      = wrap ":"
    let wrap_dot        = wrap "."
    let wrap_tilde      = wrap "~"
    let wrap_assign     = wrap ":="
    let wrap_lshift     = wrap "<<"
    let wrap_rshift     = wrap ">>"
    let wrap_eq         = wrap "="
    let wrap_eq2        = wrap "=="
    let wrap_ne         = wrap "!="
    let wrap_lt         = wrap "<"
    let wrap_gt         = wrap ">"
    let wrap_le         = wrap "<="
    let wrap_ge         = wrap ">="
    let wrap_plus_eq    = wrap "+="
    let wrap_minus_eq   = wrap "-="
    let wrap_times_eq   = wrap "*="
    let wrap_slash_eq   = wrap "/="
    let wrap_slash2_eq  = wrap "//="
    let wrap_percent_eq = wrap "%="
    let wrap_and_eq     = wrap "&="
    let wrap_or_eq      = wrap "|="
    let wrap_xor_eq     = wrap "^="
    let wrap_rshift_eq  = wrap ">>="
    let wrap_lshift_eq  = wrap "<<="
    let wrap_exp_eq     = wrap "**="
    let wrap_wild       = wrap "_"
    let wrap_grave      = wrap "`"
    let wrap_backslash  = wrap "\\"

    (* Smart constructors *)

    let mk_ARROW      region = ARROW      (wrap_arrow      region)
    let mk_XOR        region = XOR        (wrap_xor        region)
    let mk_MINUS      region = MINUS      (wrap_minus      region)
    let mk_PLUS       region = PLUS       (wrap_plus       region)
    let mk_TIMES      region = TIMES      (wrap_times      region)
    let mk_EXP        region = EXP        (wrap_exp        region)
    let mk_SLASH2     region = SLASH2     (wrap_slash2     region)
    let mk_PERCENT    region = PERCENT    (wrap_percent    region)
    let mk_LPAR       region = LPAR       (wrap_lpar       region)
    let mk_RPAR       region = RPAR       (wrap_rpar       region)
    let mk_LBRACKET   region = LBRACKET   (wrap_lbracket   region)
    let mk_RBRACKET   region = RBRACKET   (wrap_rbracket   region)
    let mk_LBRACE     region = LBRACE     (wrap_lbrace     region)
    let mk_RBRACE     region = RBRACE     (wrap_rbrace     region)
    let mk_COMMA      region = COMMA      (wrap_comma      region)
    let mk_SEMI       region = SEMI       (wrap_semi       region)
    let mk_VBAR       region = VBAR       (wrap_vbar       region)
    let mk_AMPERSAND  region = AMPERSAND  (wrap_ampersand  region)
    let mk_COLON      region = COLON      (wrap_colon      region)
    let mk_DOT        region = DOT        (wrap_dot        region)
    let mk_TILDE      region = TILDE      (wrap_tilde      region)
    let mk_LSHIFT     region = LSHIFT     (wrap_lshift     region)
    let mk_RSHIFT     region = RSHIFT     (wrap_rshift     region)
    let mk_EQ         region = EQ         (wrap_eq         region)
    let mk_EQ2        region = EQ2        (wrap_eq2        region)
    let mk_NE         region = NE         (wrap_ne         region)
    let mk_LT         region = LT         (wrap_lt         region)
    let mk_GT         region = GT         (wrap_gt         region)
    let mk_LE         region = LE         (wrap_le         region)
    let mk_GE         region = GE         (wrap_ge         region)
    let mk_PLUS_EQ    region = PLUS_EQ    (wrap_plus_eq    region)
    let mk_MINUS_EQ   region = MINUS_EQ   (wrap_minus_eq   region)
    let mk_TIMES_EQ   region = TIMES_EQ   (wrap_times_eq   region)
    let mk_SLASH2_EQ  region = SLASH2_EQ  (wrap_slash2_eq  region)
    let mk_PERCENT_EQ region = PERCENT_EQ (wrap_percent_eq region)
    let mk_AND_EQ     region = AND_EQ     (wrap_and_eq     region)
    let mk_OR_EQ      region = OR_EQ      (wrap_or_eq      region)
    let mk_XOR_EQ     region = XOR_EQ     (wrap_xor_eq     region)
    let mk_RSHIFT_EQ  region = RSHIFT_EQ  (wrap_rshift_eq  region)
    let mk_LSHIFT_EQ  region = LSHIFT_EQ  (wrap_lshift_eq  region)
    let mk_EXP_EQ     region = EXP_EQ     (wrap_exp_eq     region)
    let mk_WILD       region = WILD       (wrap_wild       region)
    let mk_GRAVE      region = GRAVE      (wrap_grave      region)
    let mk_BACKSLASH  region = BACKSLASH  (wrap_backslash  region)

    (* All symbol smart constructors *)

    let symbols = [
      mk_ARROW;
      mk_XOR;
      mk_MINUS;
      mk_PLUS;
      mk_TIMES;
      mk_EXP;
      mk_SLASH2;
      mk_PERCENT;
      mk_LPAR;
      mk_RPAR;
      mk_LBRACKET;
      mk_RBRACKET;
      mk_LBRACE;
      mk_RBRACE;
      mk_COMMA;
      mk_SEMI;
      mk_VBAR;
      mk_AMPERSAND;
      mk_COLON;
      mk_DOT;
      mk_TILDE;
      mk_LSHIFT;
      mk_RSHIFT;
      mk_EQ;
      mk_EQ2;
      mk_NE;
      mk_LT;
      mk_GT;
      mk_LE;
      mk_GE;
      mk_PLUS_EQ;
      mk_MINUS_EQ;
      mk_TIMES_EQ;
      mk_SLASH2_EQ;
      mk_PERCENT_EQ;
      mk_AND_EQ;
      mk_OR_EQ;
      mk_XOR_EQ;
      mk_RSHIFT_EQ;
      mk_LSHIFT_EQ;
      mk_EXP_EQ;
      mk_WILD;
      mk_GRAVE;
      mk_BACKSLASH
    ]

    (* All symbols *)

    let symbols =
      let add map (key, data) =
        match SMap.add ~key ~data map with
          `Ok map -> map
        | `Duplicate -> map in
      let apply map mk_sym =
        let lexemes = to_lexeme (mk_sym Region.ghost) in
        List.fold_left ~f:(fun map lex -> add map (lex, mk_sym))
                       ~init:map lexemes
      in List.fold_left ~f:apply ~init:SMap.empty symbols

    (* Ghost symbols *)

    let ghost_arrow      = wrap_arrow      Region.ghost
    let ghost_xor        = wrap_xor        Region.ghost
    let ghost_minus      = wrap_minus      Region.ghost
    let ghost_plus       = wrap_plus       Region.ghost
    let ghost_times      = wrap_times      Region.ghost
    let ghost_exp        = wrap_exp        Region.ghost
    let ghost_slash      = wrap_slash      Region.ghost
    let ghost_slash2     = wrap_slash2     Region.ghost
    let ghost_percent    = wrap_percent    Region.ghost
    let ghost_at         = wrap_at         Region.ghost
    let ghost_lpar       = wrap_lpar       Region.ghost
    let ghost_rpar       = wrap_rpar       Region.ghost
    let ghost_lbracket   = wrap_lbracket   Region.ghost
    let ghost_rbracket   = wrap_rbracket   Region.ghost
    let ghost_lbrace     = wrap_lbrace     Region.ghost
    let ghost_rbrace     = wrap_rbrace     Region.ghost
    let ghost_comma      = wrap_comma      Region.ghost
    let ghost_semi       = wrap_semi       Region.ghost
    let ghost_vbar       = wrap_vbar       Region.ghost
    let ghost_ampersand  = wrap_ampersand  Region.ghost
    let ghost_colon      = wrap_colon      Region.ghost
    let ghost_dot        = wrap_dot        Region.ghost
    let ghost_tilde      = wrap_tilde      Region.ghost
    let ghost_assign     = wrap_assign     Region.ghost
    let ghost_lshift     = wrap_lshift     Region.ghost
    let ghost_rshift     = wrap_rshift     Region.ghost
    let ghost_eq         = wrap_eq         Region.ghost
    let ghost_eq2        = wrap_eq2        Region.ghost
    let ghost_ne         = wrap_ne         Region.ghost
    let ghost_lt         = wrap_lt         Region.ghost
    let ghost_gt         = wrap_gt         Region.ghost
    let ghost_le         = wrap_le         Region.ghost
    let ghost_ge         = wrap_ge         Region.ghost
    let ghost_plus_eq    = wrap_plus_eq    Region.ghost
    let ghost_minus_eq   = wrap_minus_eq   Region.ghost
    let ghost_times_eq   = wrap_times_eq   Region.ghost
    let ghost_slash_eq   = wrap_slash_eq   Region.ghost
    let ghost_slash2_eq  = wrap_slash2_eq  Region.ghost
    let ghost_percent_eq = wrap_percent_eq Region.ghost
    let ghost_and_eq     = wrap_and_eq     Region.ghost
    let ghost_or_eq      = wrap_or_eq      Region.ghost
    let ghost_xor_eq     = wrap_xor_eq     Region.ghost
    let ghost_rshift_eq  = wrap_rshift_eq  Region.ghost
    let ghost_lshift_eq  = wrap_lshift_eq  Region.ghost
    let ghost_exp_eq     = wrap_exp_eq     Region.ghost
    let ghost_wild       = wrap_wild       Region.ghost
    let ghost_grave      = wrap_grave      Region.ghost
    let ghost_backslash  = wrap_backslash  Region.ghost

    let ghost_ARROW      = ARROW      ghost_arrow
    let ghost_XOR        = XOR        ghost_xor
    let ghost_MINUS      = MINUS      ghost_minus
    let ghost_PLUS       = PLUS       ghost_plus
    let ghost_TIMES      = TIMES      ghost_times
    let ghost_EXP        = EXP        ghost_exp
    let ghost_SLASH2     = SLASH2     ghost_slash2
    let ghost_PERCENT    = PERCENT    ghost_percent
    let ghost_LPAR       = LPAR       ghost_lpar
    let ghost_RPAR       = RPAR       ghost_rpar
    let ghost_LBRACKET   = LBRACKET   ghost_lbracket
    let ghost_RBRACKET   = RBRACKET   ghost_rbracket
    let ghost_LBRACE     = LBRACE     ghost_lbrace
    let ghost_RBRACE     = RBRACE     ghost_rbrace
    let ghost_COMMA      = COMMA      ghost_comma
    let ghost_SEMI       = SEMI       ghost_semi
    let ghost_VBAR       = VBAR       ghost_vbar
    let ghost_AMPERSAND  = AMPERSAND  ghost_ampersand
    let ghost_COLON      = COLON      ghost_colon
    let ghost_DOT        = DOT        ghost_dot
    let ghost_TILDE      = TILDE      ghost_tilde
    let ghost_LSHIFT     = LSHIFT     ghost_lshift
    let ghost_RSHIFT     = RSHIFT     ghost_rshift
    let ghost_EQ         = EQ         ghost_eq
    let ghost_EQ2        = EQ2        ghost_eq2
    let ghost_NE         = NE         ghost_ne
    let ghost_LT         = LT         ghost_lt
    let ghost_GT         = GT         ghost_gt
    let ghost_LE         = LE         ghost_le
    let ghost_GE         = GE         ghost_ge
    let ghost_PLUS_EQ    = PLUS_EQ    ghost_plus_eq
    let ghost_MINUS_EQ   = MINUS_EQ   ghost_minus_eq
    let ghost_TIMES_EQ   = TIMES_EQ   ghost_times_eq
    let ghost_SLASH2_EQ  = SLASH2_EQ  ghost_slash2_eq
    let ghost_PERCENT_EQ = PERCENT_EQ ghost_percent_eq
    let ghost_AND_EQ     = AND_EQ     ghost_and_eq
    let ghost_OR_EQ      = OR_EQ      ghost_or_eq
    let ghost_XOR_EQ     = XOR_EQ     ghost_xor_eq
    let ghost_RSHIFT_EQ  = RSHIFT_EQ  ghost_rshift_eq
    let ghost_LSHIFT_EQ  = LSHIFT_EQ  ghost_lshift_eq
    let ghost_EXP_EQ     = EXP_EQ     ghost_exp_eq
    let ghost_WILD       = WILD       ghost_wild
    let ghost_GRAVE      = GRAVE      ghost_grave
    let ghost_BACKSLASH  = BACKSLASH  ghost_backslash

    (* OTHER GHOST TOKENS *)

    (* IMPORTANT: These values cannot be exported in Token.mli *)

    let wrap_string   s = wrap s
    let wrap_verbatim s = wrap s
    let wrap_bytes    b = wrap ("0x" ^ Hex.show b, b)
    let wrap_int      z = wrap (Z.to_string z, z)
    let wrap_nat      z = wrap (Z.to_string z ^ "n", z)
    let wrap_mutez    m = wrap (Int64.to_string m ^ "mutez", m)
    let wrap_tez      t = wrap (Int64.to_string t ^ "tez", t)
    let wrap_ident    i = wrap i
    let wrap_uident   i = wrap i
    let wrap_eident   i = wrap i

    let wrap_attr key value region =
      Region.{value = (key, value); region}

    let wrap_lang lang region =
      let start = region#start#shift_bytes (String.length "[%") in
      let lang_reg = Region.make ~start ~stop:region#stop in
      Region.{region; value = {value=lang; region=lang_reg}}

    let ghost_string   s = wrap_string   s   Region.ghost
    let ghost_verbatim s = wrap_verbatim s   Region.ghost
    let ghost_bytes    b = wrap_bytes    b   Region.ghost
    let ghost_int      z = wrap_int      z   Region.ghost
    let ghost_nat      z = wrap_nat      z   Region.ghost
    let ghost_mutez    m = wrap_mutez    m   Region.ghost
    let ghost_tez      m = wrap_tez      m   Region.ghost
    let ghost_ident    i = wrap_ident    i   Region.ghost
    let ghost_uident   i = wrap_uident   i   Region.ghost
    let ghost_eident   i = wrap_eident   i   Region.ghost
    let ghost_attr   k v = wrap_attr     k v Region.ghost
    let ghost_lang     l = wrap_lang     l   Region.ghost

    let ghost_String   s = String   (ghost_string s)
    let ghost_Verbatim s = Verbatim (ghost_verbatim s)
    let ghost_Bytes    b = Bytes    (ghost_bytes b)
    let ghost_Int      z = Int      (ghost_int z)
    let ghost_Nat      z = Nat      (ghost_nat z)
    let ghost_Mutez    m = Mutez    (ghost_mutez m)
    let ghost_Tez      m = Tez      (ghost_tez m)
    let ghost_Ident    i = Ident    (ghost_ident i)
    let ghost_UIdent   i = UIdent   (ghost_uident i)
    let ghost_EIdent   i = EIdent   (ghost_eident i)
    let ghost_Attr   k v = Attr     (ghost_attr k v)
    let ghost_Lang     l = Lang     (ghost_lang l)

    (* VIRTUAL TOKENS *)

    (* Blocks of statements *)

    let wrap_begin      = wrap ""
    let ghost_begin     = wrap_begin Region.ghost
    let mk_BEGIN region = BEGIN (wrap_begin region)
    let ghost_BEGIN     = mk_BEGIN Region.ghost

    let wrap_end      = wrap ""
    let ghost_end     = wrap_end Region.ghost
    let mk_END region = END (wrap_end region)
    let ghost_END     = mk_END Region.ghost

    (* Indentations *)

    let wrap_indent = wrap 2 (* TODO *)
    let mk_INDENT Region.{value; region} = INDENT (wrap value region)

    (* Top-level *)

    let wrap_top_level      = wrap ()
    let ghost_top_level     = wrap_top_level Region.ghost
    let mk_TOP_LEVEL region = TOP_LEVEL (wrap_top_level region)
    let ghost_TOP_LEVEL     = mk_TOP_LEVEL Region.ghost

    (* Zero-Width SPace *)

    let wrap_zwsp      = wrap ()
    let ghost_zswp     = wrap_zwsp Region.ghost
    let mk_ZWSP region = ZWSP (wrap_zwsp region)
    let ghost_ZWSP     = mk_ZWSP Region.ghost

    (* END-OF-FILE TOKEN *)

    let wrap_eof      = wrap ""
    let mk_EOF region = EOF (wrap_eof region)
    let ghost_eof     = wrap_eof Region.ghost
    let ghost_EOF     = mk_EOF Region.ghost

    (* FROM TOKEN STRINGS TO LEXEMES *)

    let concrete = function
      "Ident"    -> "x"
    | "UIdent"   -> "X"
    | "EIdent"   -> "@x"
    | "Int"      -> "1"
    | "Nat"      -> "1n"
    | "Mutez"    -> "1mutez"
    | "Tez"      -> "1tez"
    | "String"   -> "\"a string\""
    | "Verbatim" -> "{|verbatim|}"
    | "Bytes"    -> "0xAA"
    | "Attr"     -> "[@attr]"
    | "Lang"     -> "[%Michelson"

    (* Symbols *)

    | "ARROW"      -> ghost_arrow#payload
    | "XOR"        -> ghost_xor#payload
    | "MINUS"      -> ghost_minus#payload
    | "PLUS"       -> ghost_plus#payload
    | "TIMES"      -> ghost_times#payload
    | "EXP"        -> ghost_exp#payload
    | "SLASH2"     -> ghost_slash2#payload
    | "PERCENT"    -> ghost_percent#payload
    | "LPAR"       -> ghost_lpar#payload
    | "RPAR"       -> ghost_lpar#payload
    | "LBRACKET"   -> ghost_lbracket#payload
    | "RBRACKET"   -> ghost_rbracket#payload
    | "LBRACE"     -> ghost_lbrace#payload
    | "RBRACE"     -> ghost_rbrace#payload
    | "COMMA"      -> ghost_comma#payload
    | "SEMI"       -> ghost_semi#payload
    | "VBAR"       -> ghost_vbar#payload
    | "AMPERSAND"  -> ghost_ampersand#payload
    | "COLON"      -> ghost_colon#payload
    | "DOT"        -> ghost_dot#payload
    | "TILDE"      -> ghost_tilde#payload
    | "LSHIFT"     -> ghost_lshift#payload
    | "RSHIFT"     -> ghost_rshift#payload
    | "EQ"         -> ghost_eq#payload
    | "EQ2"        -> ghost_eq2#payload
    | "NE"         -> ghost_ne#payload
    | "LT"         -> ghost_lt#payload
    | "GT"         -> ghost_gt#payload
    | "LE"         -> ghost_le#payload
    | "GE"         -> ghost_ge#payload
    | "PLUS_EQ"    -> ghost_plus_eq#payload
    | "MINUS_EQ"   -> ghost_minus_eq#payload
    | "TIMES_EQ"   -> ghost_times_eq#payload
    | "SLASH2_EQ"  -> ghost_slash2_eq#payload
    | "PERCENT_EQ" -> ghost_percent_eq#payload
    | "AND_EQ"     -> ghost_and_eq#payload
    | "OR_EQ"      -> ghost_or_eq#payload
    | "XOR_EQ"     -> ghost_xor_eq#payload
    | "RSHIFT_EQ"  -> ghost_rshift_eq#payload
    | "LSHIFT_EQ"  -> ghost_lshift_eq#payload
    | "EXP_EQ"     -> ghost_exp_eq#payload
    | "WILD"       -> ghost_wild#payload
    | "GRAVE"      -> ghost_grave#payload
    | "BACKSLASH"  -> ghost_backslash#payload

    (* Keywords *)

    | "And"      -> ghost_and#payload
(*  | "As"       -> ghost_as#payload *)
    | "Assert"   -> ghost_assert#payload
(*  | "Async"    -> ghost_async#payload
    | "Await"    -> ghost_await#payload
    | "Break"    -> ghost_break#payload *)
    | "Case"     -> ghost_case#payload
    | "Class"    -> ghost_class#payload
(*  | "Continue" -> ghost_continue#payload *)
    | "Const"    -> ghost_const#payload
    | "Def"      -> ghost_def#payload
(*  | "Del"      -> ghost_del#payload *)
    | "Elif"     -> ghost_elif#payload
    | "Else"     -> ghost_else#payload
(*  | "Except"   -> ghost_except#payload
    | "Finally"  -> ghost_finally#payload *)
    | "For"      -> ghost_for#payload
(*  | "From"     -> ghost_from#payload
    | "Global"   -> ghost_global#payload *)
    | "If"       -> ghost_if#payload
    | "In"       -> ghost_in#payload
(*  | "Is"       -> ghost_is#payload
    | "Import"   -> ghost_import#payload *)
    | "Lambda"   -> ghost_lambda#payload
    | "Match"    -> ghost_match#payload
    | "Module"   -> ghost_module#payload
(*  | "Nonlocal" -> ghost_nonlocal#payload *)
    | "Not"      -> ghost_not#payload
    | "Or"       -> ghost_or#payload
    | "Pass"     -> ghost_pass#payload
(*  | "Raise"    -> ghost_raise#payload *)
    | "Return"   -> ghost_return#payload
(*  | "Try"      -> ghost_try#payload *)
    | "Type"     -> ghost_type#payload
    | "Var"      -> ghost_var#payload
    | "While"    -> ghost_while#payload
(*  | "With"     -> ghost_with#payload
    | "Yield"    -> ghost_yield#payload *)

    (* Virtual tokens *)

    | "BEGIN"     -> ""
    | "END"       -> ""
    | "INDENT"    -> ""
    | "TOP_LEVEL" -> ""
    | "ZWSP"      -> ""

    (* End-Of-File *)

    | "EOF" -> ghost_eof#payload

    (* This case should not happen! *)

    | _  -> "\\Unknown" (* Backslash meant to trigger an error *)


    (* FROM TOKENS TO TOKEN STRINGS AND REGIONS *)

    let proj_token = function
      (* Preprocessing directives *)

      Directive d -> Directive.project d

      (* Literals *)

    | String t ->
        t#region, sprintf "String %S" t#payload
    | Verbatim t ->
        t#region, sprintf "Verbatim %S" t#payload
    | Bytes t ->
        let s, b = t#payload in
        t#region,
        sprintf "Bytes (%S, \"0x%s\")" s (Hex.show b)
    | Int t ->
        let s, n = t#payload in
        t#region, sprintf "Int (%S, %s)" s (Z.to_string n)
    | Nat t ->
        let s, n = t#payload in
        t#region, sprintf "Nat (%S, %s)" s (Z.to_string n)
    | Mutez t ->
        let s, n = t#payload in
        t#region, sprintf "Mutez (%S, %s)" s (Int64.to_string n)
    | Tez t ->
        let s, n = t#payload in
        t#region, sprintf "Tez (%S, %s)" s (Int64.to_string n)
    | Ident t ->
        t#region, sprintf "Ident %S" t#payload
    | UIdent t ->
        t#region, sprintf "UIdent %S" t#payload
    | EIdent t ->
        t#region, sprintf "EIdent %S" t#payload
    | Attr {region; value} ->
        region, sprintf "Attr %s" (Attr.to_string value)
    | Lang {value = {value = payload; _}; region; _} ->
        region, sprintf "Lang %S" payload

    (* Symbols *)

    | ARROW      t -> t#region, "ARROW"
    | XOR        t -> t#region, "XOR"
    | MINUS      t -> t#region, "MINUS"
    | PLUS       t -> t#region, "PLUS"
    | TIMES      t -> t#region, "TIMES"
    | EXP        t -> t#region, "EXPR"
    | SLASH2     t -> t#region, "SLASH2"
    | PERCENT    t -> t#region, "PERCENT"
    | LPAR       t -> t#region, "LPAR"
    | RPAR       t -> t#region, "RPAR"
    | LBRACKET   t -> t#region, "LBRACKET"
    | RBRACKET   t -> t#region, "RBRACKET"
    | LBRACE     t -> t#region, "LBRACE"
    | RBRACE     t -> t#region, "RBRACE"
    | COMMA      t -> t#region, "COMMA"
    | SEMI       t -> t#region, "SEMI"
    | VBAR       t -> t#region, "VBAR"
    | AMPERSAND  t -> t#region, "AMPERSAND"
    | COLON      t -> t#region, "COLON"
    | DOT        t -> t#region, "DOT"
    | TILDE      t -> t#region, "TILDE"
    | LSHIFT     t -> t#region, "LSHIFT"
    | RSHIFT     t -> t#region, "RSHIFT"
    | EQ         t -> t#region, "EQ"
    | EQ2        t -> t#region, "EQ2"
    | NE         t -> t#region, "NE"
    | LT         t -> t#region, "LT"
    | GT         t -> t#region, "GT"
    | LE         t -> t#region, "LE"
    | GE         t -> t#region, "GE"
    | PLUS_EQ    t -> t#region, "PLUS_EQ"
    | MINUS_EQ   t -> t#region, "MINUS_EQ"
    | TIMES_EQ   t -> t#region, "TIMES_EQ"
    | SLASH2_EQ  t -> t#region, "SLASH2_EQ"
    | PERCENT_EQ t -> t#region, "PERCENT_EQ"
    | AND_EQ     t -> t#region, "AND_EQ"
    | OR_EQ      t -> t#region, "OR_EQ"
    | XOR_EQ     t -> t#region, "XOR_EQ"
    | RSHIFT_EQ  t -> t#region, "RSHIFT_EQ"
    | LSHIFT_EQ  t -> t#region, "LSHIFT_EQ"
    | EXP_EQ     t -> t#region, "EXP_EQ"
    | WILD       t -> t#region, "WILD"
    | GRAVE      t -> t#region, "GRAVE"
    | BACKSLASH  t -> t#region, "BACKSLASH"

    (* Keywords *)

    | And      t -> t#region, "And"
(*  | As       t -> t#region, "As" *)
    | Assert   t -> t#region, "Assert"
(*  | Async    t -> t#region, "Async"
    | Await    t -> t#region, "Await"
    | Break    t -> t#region, "Break" *)
    | Case     t -> t#region, "Case"
    | Class    t -> t#region, "Class"
(*  | Continue t -> t#region, "Continue" *)
    | Const    t -> t#region, "Const"
    | Def      t -> t#region, "Def"
(*  | Del      t -> t#region, "Del" *)
    | Elif     t -> t#region, "Elif"
    | Else     t -> t#region, "Else"
(*  | Except   t -> t#region, "Except"
    | Finally  t -> t#region, "Finally" *)
    | For      t -> t#region, "For"
(*  | From     t -> t#region, "From"
    | Global   t -> t#region, "Global" *)
    | If       t -> t#region, "If"
    | In       t -> t#region, "In"
(*  | Is       t -> t#region, "Is"
    | Import   t -> t#region, "Import" *)
    | Lambda   t -> t#region, "Lambda"
    | Match    t -> t#region, "Match"
    | Module   t -> t#region, "Module"
(*  | Nonlocal t -> t#region, "Nonlocal" *)
    | Not      t -> t#region, "Not"
    | Or       t -> t#region, "Or"
    | Pass     t -> t#region, "Pass"
(*  | Raise    t -> t#region, "Raise" *)
    | Return   t -> t#region, "Return"
(*  | Try      t -> t#region, "Try" *)
    | Type     t -> t#region, "Type"
    | Var      t -> t#region, "Var"
    | While    t -> t#region, "While"
(*  | With     t -> t#region, "With"
    | Yield    t -> t#region, "Yield" *)

    (* Virtual tokens *)

    | BEGIN     t -> t#region, "BEGIN"
    | END       t -> t#region, "END"
    | INDENT    t -> t#region, sprintf "INDENT %S" (String.make t#payload ' ')
    | TOP_LEVEL t -> t#region, "TOP_LEVEL"
    | ZWSP      t -> t#region, "ZWSP"

    (* End-Of-File *)

    | EOF t -> t#region, "EOF"


    (* CONVERSIONS *)

    let to_string ~offsets mode token =
      let region, val_str = proj_token token in
      let reg_str = region#compact ~offsets mode
      in sprintf "%s: %s" reg_str val_str

    let to_region token = proj_token token |> fst


    (* SMART CONSTRUCTORS *)

    (* Keywords *)

    type kwd_err = Invalid_keyword

    let mk_kwd ident region =
      match SMap.find keywords ident with
        Some mk_kwd -> Ok (mk_kwd region)
      |        None -> Error Invalid_keyword

    (* Directives *)

    let mk_directive dir = Directive dir

    (* Strings *)

    let mk_string lexeme region = String (wrap lexeme region)

    (* Verbatim strings *)

    let mk_verbatim lexeme region = Verbatim (wrap lexeme region)

    (* Bytes *)

    let mk_bytes lexeme bytes region =
      Bytes (wrap ("0x" ^ lexeme, `Hex bytes) region)

    (* Integers *)

    let mk_int lexeme z region = Int (wrap (lexeme, z) region)

    (* Natural numbers *)

    type nat_err = Wrong_nat_syntax of string (* Not PyLIGO *)

    let mk_nat nat z region = Ok (Nat (wrap (nat ^ "n", z) region))

    (* Mutez *)
    let mk_mutez nat ~suffix int64 region =
      Mutez (wrap (nat ^ suffix, int64) region)

    (* Tez *)
    let mk_tez nat ~suffix int64 region =
      Tez (wrap (nat ^ suffix, int64) region)

    (* End-Of-File *)

    let mk_eof region = EOF (wrap "" region)

    (* Symbols *)

    type sym_err = Invalid_symbol of string

    let mk_sym lexeme region =
      match SMap.find symbols lexeme with
        Some mk_sym -> Ok (mk_sym region)
      |        None -> Error (Invalid_symbol lexeme)

    (* Identifiers *)

    let mk_ident value region =
      match SMap.find keywords value with
        Some mk_kwd -> mk_kwd region
      |        None -> Ident (wrap value region)

    (* Escaped identifiers *)

    let mk_eident value region = EIdent (wrap value region)

    (* Constructors/Modules *)

    let mk_uident value region = UIdent (wrap value region)

    (* Attributes *)

    let mk_attr ~key ?value region = Attr {region; value = key, value}

    (* Code injection *)

    type lang_err = Wrong_lang_syntax of string (* Not PyLIGO *)

    let mk_lang lang region = Ok (Lang Region.{value=lang; region})

    (* PREDICATES *)

    let is_int    = function Int    _ -> true | _ -> false
    let is_string = function String _ -> true | _ -> false
    let is_bytes  = function Bytes  _ -> true | _ -> false
    let is_eof    = function EOF    _ -> true | _ -> false

    let hex_digits = ["A"; "B"; "C"; "D"; "E"; "F";
                      "a"; "b"; "c"; "d"; "e"; "f"]

    let is_hex = function
      UIdent t | Ident t ->
        List.mem hex_digits t#payload ~equal:String.equal
    | _ -> false

    let is_sym = function
      ARROW      _
    | XOR        _
    | MINUS      _
    | PLUS       _
    | TIMES      _
    | EXP        _
    | SLASH2     _
    | PERCENT    _
    | LPAR       _
    | RPAR       _
    | LBRACKET   _
    | RBRACKET   _
    | LBRACE     _
    | RBRACE     _
    | COMMA      _
    | SEMI       _
    | VBAR       _
    | AMPERSAND  _
    | COLON      _
    | DOT        _
    | TILDE      _
    | LSHIFT     _
    | RSHIFT     _
    | EQ         _
    | EQ2        _
    | NE         _
    | LT         _
    | GT         _
    | LE         _
    | GE         _
    | PLUS_EQ    _
    | MINUS_EQ   _
    | TIMES_EQ   _
    | SLASH2_EQ  _
    | PERCENT_EQ _
    | AND_EQ     _
    | OR_EQ      _
    | XOR_EQ     _
    | RSHIFT_EQ  _
    | LSHIFT_EQ  _
    | EXP_EQ     _
    | WILD       _
    | GRAVE      _
    | BACKSLASH  _ -> true
    | _ -> false

    (* Verbatim strings *)

    let verbatim_delimiters = ("{|", "|}")
  end

include T

module type S = module type of T
